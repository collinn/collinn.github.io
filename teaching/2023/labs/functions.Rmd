---
title: "Functions, Loops, and Files"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: false
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(dplyr)
library(magrittr)
```

# Lab

This lab is going to cover functions, loops and conditionals, and files, all of which serve important roles in the R language, as well as in data science more generally.

## Functions

Functions, in their most essential definition, can be thought of as mini computer programs, pre-packaged snippets of code that assist us in doing common or repetitive tasks. Thus far in the course, we have used functions extensively, from complex tasks such as generating the beautifully rendered ggplots to computing the arithmetic mean. Most of the functions we have used take *arguments* or different variables, though this is not always the case. While there are many reasons to use functions, perhaps one of the most important for us is to standardize repetitive tasks. If we find ourselves copy-and-pasting code over and over again to do something similar, this is a hint that we need to write a function. Functions are also helpful in this regard in case there is an error in our code; using the copy-and-paste method, any errors that we find will have to be corrected in each place, whereas with a function, we only need to fix the error within the function.

Functions in R are similar to functions in other programming language, with the more important differences being beyond the scope of this class. In this portion of the lab, we will familiarize ourselves with how to create functions and use them in our own work.

Functions in R primarily consist of three components:

  1. The name of the function
  2. The arguments of the function
  3. The body of the function
  
Functions in R begin with an assignment with `<-` to a name, along with the function `function()`, followed by the body of the function enclosed in curly brackets `{}`. Here, for example, is a function that computes the sum of squares of two inputs, `x` and `y`

```{r}
sum_of_squares <- function(x, y) {
  x^2 + y^2
}

sum_of_squares(x = 2, y = 3)
```

We can also write functions that take *default arguments*. For example, in the `sum_of_squares()` function, if we do not provide both an `x` and `y`, we will get an error:

```{r, error = TRUE}
sum_of_squares(x = 2)
```

We can rewrite our function so that we have a default argument with `y = 3`. Note that the default *only* applies when an argument for `y` is not given; if we do supply an argument to `y`, the default with be ignored.

```{r}
sum_of_squares_default <- function(x, y = 3) {
  x^2 + y^2
}

# Using the default argument
sum_of_squares_default(x = 2)

# Providing our own
sum_of_squares_default(x = 2, y = 10)
```


**Question 1** Recall from previous homework that we had introduced both the police and college datasets. 

```{r}
police <- read.csv("https://remiller1450.github.io/data/Police2019.csv")
college <- read.csv("https://remiller1450.github.io/data/Colleges2019.csv")
```

Your goal is to write a function called `top_table` that takes a character vector and returns the names of the values with the top five occurrences. Recall, this is precisely what was done in Homework 1. Then, verify that it works by printing out the top five states in both the police and college datasets. Your results should look like this:

```{r, echo = FALSE}
top_table <- function(v, n = 5) {
  tv <- table(v) %>% sort(decreasing = TRUE)
  print(tv[1:n])
}
```

```{r}
top_table(police$state)
top_table(college$State)
```

**Question 2** Modify `top_table` so that it takes an additional argument `n` that allows you to specify that you want to view the top N values in each vector. Here, for example, we print the top 10:

```{r}
top_table(police$state, n = 10)
top_table(college$State, n = 10)
```


## Loops and Conditionals

Here, we introduce the concept of loops and conditionals, both of which are common in other programming languages. 


### Loops

The concept of a loop is straightforward enough: given a vector of values, we will *loop* through each one, performing some operation. Similar to functions, loops have a particular syntax to initiate a loop and then enclose the resulting expression between curly brackets.

Loops begin with a syntax that takes the form of something like `for (i in 1:10)` which we read as "for the variable *i* in the vector 1 to 10...". In this case, the loop will *loop* through the vector `1:10`, in each iteration assigning the variable `i` first the number 1, then 2, continuing until it has exhausted the vector. A simple loop may look like this

```{r}
library(stringr)
for (i in 1:10) {
  print(str_c("The variable 'i' is now equal to: ", i, collapse = ""))
}
```

Note: we often have to use the `print()` function inside of a loop if we wish to print the output to the console.

Of course, we do not have to use the variable `i` for this, any other variable will do. Perhaps strangely, we do not even need to use an iterative vector for this. We can loop through the values of any vector by using it instead of the `1:10`

```{r}
vec <- c(1,3,5,7,9)
for (v in vec) {
  print(v)
}
```

Finally, we can combine the logic of both of these operations to both loop through an iterative vector while still accessing the values stored in a vector. First, we will use the `seq_along()` function which creates a sequential vector the same length as it's argument:

```{r}
vec <- c(1,3,5,7,9)
seq_along(vec)
```

and combine with with the positional indices that we learned about in Lab 1

```{r}
vec <- c(1,3,5,7,9)

# Loop along the positions of vec
for (i in seq_along(vec)) {
  print(str_c("The ", i, " position of the vector 'vec' is: ", vec[i], collapse = ""))
}
```

This is useful, for example, if we wish to loop along the columns of a data frame

```{r}
df <- data.frame(x = 1:5, 
                 y = 6:10, 
                 z = 11:15)
df

# mean of each column
for (i in 1:ncol(df)) {
  print(mean(df[, i]))
}
```

Finally, if we wish to save the output of a loop, we can do so by creating a vector that is the same length as the vector we are iterating over and assigning the results to each position. For a numeric vector, we can create this with the function `numeric()`

```{r}
df <- data.frame(x = 1:5, 
                 y = 6:10, 
                 z = 11:15)

results <- numeric(length = ncol(df))

for (i in 1:ncol(df)) {
  # ith value of results is mean of ith column of df
  results[i] <- mean(df[, i])
}

results
```


### Conditionals

Conditionals, like loops and functions, are basic data structures in R that involve a special syntax followed by expressions enclosed in curly brackets. Conditionals take a logical value (`TRUE` or `FALSE`) and, based on this value, evaluate on expression or the other. The special syntax used in conditionals are `if ()`, `if else ()` and `else`. Both `if` and `if else` take an argument that may be true or false and will evaluate their expression accordingly; `else`, on the other hand, will always evaluate if none of its previous conditions were met

We can best see how these work with a simple example.

```{r}
d <- 5

if (d > 7) {
  print("yay")
} else if (d < 4) {
  print("boo")
} else {
  print("hiss")
}
```

The only syntax needed to perform a conditional if the `if` function. If the condition fails to be true and there is no `else`, the sequence is simply ignored.

```{r}

## This is ignored, there is no else
a <- 4
if (a > 5) {
  a <- a^2
}
a

# This one is not ignored
b <- 5
if (b > 3) {
  b <- b^2 + 5
}
b
```

Lastly, one can create as many `if else` conditions as their heart desires

```{r}
a <- 4

if (a == 1) {
  print("a is 1")
} else if (a == 2) {
  print("a is 2")
} else if (a == 3) {
  print("a is 3")
} else if (a == 4) {
  print("a is 4")
} else {
  print("I don't know what 'a' is")
}
```

**Question 3** Write a function called `long_square` that takes a single numeric argument `n`. If the length of the vector is greater than the square root of the sum of all the numbers in the vector, the function should print `"long!"`. Otherwise, is should print `"not long!"`. Verify that it works for the arguments `x1`, `x2`, and `x3`.

```{r, echo = FALSE}
long_square <- function(n) {
  nl <- length(n)
  ns <- sqrt(sum(n))
  if (nl > ns) {
    print("long!")
  } else {
    print("not long!")
  }
}

x <- c(1, 2, 3, 4, 5)
x <- c(5, 8, 10, 12)
x <- c(2, 5, 9, 10, 1, 1, 1)

long_square(x)
```

```{r}
x1 <- c(1, 2, 3, 4, 5)
x2 <- c(5, 8, 10, 12)
x3 <- c(2, 5, 9, 10, 1, 1, 1)

long_square(n = x1)
long_square(n = x2)
long_square(n = x3)
```

**Question 4** Here, we are going to modify the `top_table` function we wrote in Question 1 once more. In addition to having a second argument `n` indicating the number of results, we now want to include a third argument `top` which takes either `TRUE` or `FALSE`. When `TRUE`, the function should return the top `n` rows; when `FALSE`, it should return the bottom `n`.

```{r, echo = FALSE}
top_table <- function(v, n = 5, top = TRUE) {
  tv <- table(v) %>% sort(decreasing = top)
  print(tv[1:n])
}
```

```{r}
top_table(police$state, n = 5, top = TRUE)
top_table(college$State, n = 10, top = FALSE)
```


## Files


TBD


























